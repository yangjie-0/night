# 错误隔离机制说明

## 概要

各个表之间的数据插入已经完全隔离，即使某个表出现问题，也不会影响其他表的数据插入。

---

## 隔离机制详细说明

### ✅ 核心原则

**即使制品表（m_product_management）出现任何问题，商品表（m_product, m_product_eav）的数据也会正常保存。**

---

## 处理流程

### 正常流程（所有表都正常）

```
BEGIN TRANSACTION
  ├─ 商品識別（m_product_ident）        ✅ 成功
  ├─ 商品マスタ（m_product）            ✅ 成功
  ├─ 商品EAV（m_product_eav）           ✅ 成功
  └─ 【KM会社】製品マスタ（m_product_management） ✅ 成功
COMMIT ✅

結果：すべてのテーブルにデータが保存される
```

---

### 场景1：制品表不存在

```
BEGIN TRANSACTION
  ├─ 商品識別（m_product_ident）        ✅ 成功
  ├─ 商品マスタ（m_product）            ✅ 成功
  ├─ 商品EAV（m_product_eav）           ✅ 成功
  └─ 【KM会社】製品マスタ処理
      ├─ テーブル存在チェック ❌ テーブルが存在しない
      ├─ 警告ログを出力：「m_product_management テーブルが存在しません」
      └─ return（処理をスキップ、例外は投げない）
COMMIT ✅

結果：商品マスタと商品EAVは正常に保存される
      製品マスタはスキップされる

ログ出力：
[WARN] 製品マスタスキップ: m_product_management テーブルが存在しません
[WARN] 【対処方法】init/createTable1105.sql を実行してテーブルを作成してください
[INFO] ※ 商品マスタ（m_product, m_product_eav）のデータは正常に保存されます
```

---

### 场景2：制品表存在但 batch_id 列不存在

```
BEGIN TRANSACTION
  ├─ 商品識別（m_product_ident）        ✅ 成功
  ├─ 商品マスタ（m_product）            ✅ 成功
  ├─ 商品EAV（m_product_eav）           ✅ 成功
  └─ 【KM会社】製品マスタ処理
      ├─ テーブル存在チェック ✅ 存在する
      ├─ 製品マスタINSERT試行 ❌ column "batch_id" does not exist
      ├─ catch (Exception pmEx) でキャッチ
      └─ エラーログを出力（例外は再スローしない）
COMMIT ✅

結果：商品マスタと商品EAVは正常に保存される
      製品マスタはエラーで失敗

ログ出力：
[ERROR] 製品マスタ処理エラー（商品マスタは正常）: batch_id=XXX, temp_row_id=YYY, g_product_id=ZZZ, error=column "batch_id" does not exist
[ERROR] スタックトレース: ...
```

---

### 场景3：g_category_id が NULL の場合

```
BEGIN TRANSACTION
  ├─ 商品識別（m_product_ident）        ✅ 成功
  ├─ 商品マスタ（m_product）            ✅ 成功（g_category_id は NULL でも許可される場合）
  ├─ 商品EAV（m_product_eav）           ✅ 成功
  └─ 【KM会社】製品マスタ処理
      ├─ テーブル存在チェック ✅ 存在する
      ├─ g_category_id NULL チェック ❌ NULL です
      ├─ エラーログを出力
      └─ return（処理をスキップ、例外は投げない）
COMMIT ✅

結果：商品マスタと商品EAVは正常に保存される
      製品マスタはスキップされる（g_category_id が必須のため）

ログ出力：
[ERROR] 製品マスタ作成失敗: g_category_id が NULL です (g_product_id=XXX)
[ERROR] 【原因】CATEGORY_1 属性が見つからないか、カテゴリIDへの変換に失敗しました
```

---

### 场景4：商品マスタでエラーが発生した場合

```
BEGIN TRANSACTION
  ├─ 商品識別（m_product_ident）        ✅ 成功
  ├─ 商品マスタ（m_product）            ❌ エラー（例：外部キー制約違反）
  └─ （後続の処理は実行されない）
ROLLBACK ❌

結果：すべてのテーブルにデータが保存されない
      エラーは record_error テーブルに記録される

ログ出力：
[ERROR] UPSERT異常(PG): batch_id=XXX, temp_row_id=YYY, error_cd=FIXED_COL_UPDATE_FAILED, state=23503, constraint=fk_product_category, message=...
```

---

## コードの実装箇所

### 1. 外層のエラーハンドリング

**場所：** `Services/Upsert/UpsertService.cs` 行 337-365

```csharp
// KM会社のみ製品マスタ処理を実行
if (string.Equals(batchRun.GroupCompanyCd, "KM", StringComparison.OrdinalIgnoreCase))
{
    try
    {
        // 製品マスタ処理を呼び出す
        await UpsertProductManagementAsync(...);
    }
    catch (Exception pmEx)
    {
        // エラーをログに記録するだけ（例外は再スローしない）
        Logger.Error($"製品マスタ処理エラー（商品マスタは正常）: ...");
        // トランザクションは回滚しない！
    }
}

// 商品マスタと商品EAVをコミット
await tx.CommitAsync(cancellationToken);
```

**重要ポイント：**
- 製品マスタの処理は独立した `try-catch` ブロックで囲まれている
- 例外が発生しても `catch` ブロックでキャッチし、ログを出力するだけ
- 例外を再スローしないため、外側の `tx.CommitAsync()` が必ず実行される

---

### 2. テーブル存在性チェック

**場所：** `Services/Upsert/UpsertService.cs` 行 1302-1328

```csharp
private async Task UpsertProductManagementAsync(...)
{
    // チェック0: テーブルが存在するか確認
    try
    {
        const string checkTableSql = @"
            SELECT EXISTS (
                SELECT FROM information_schema.tables
                WHERE table_schema = 'public'
                AND table_name = 'm_product_management'
            );";
        var tableExists = await connection.ExecuteScalarAsync<bool>(...);

        if (!tableExists)
        {
            Logger.Warn("製品マスタスキップ: m_product_management テーブルが存在しません");
            Logger.Warn("【対処方法】init/createTable1105.sql を実行してテーブルを作成してください");
            Logger.Info("※ 商品マスタ（m_product, m_product_eav）のデータは正常に保存されます");
            return;  // スキップ（例外は投げない）
        }
    }
    catch (Exception ex)
    {
        Logger.Error($"製品マスタテーブル存在チェック失敗: {ex.Message}");
        Logger.Info("※ 商品マスタ（m_product, m_product_eav）のデータは正常に保存されます");
        return;  // スキップ（例外は投げない）
    }

    // ... 以降の処理
}
```

**重要ポイント：**
- 任何数据库操作を実行する前に、テーブルの存在を確認
- テーブルが存在しない場合は `return` でスキップ（例外を投げない）
- チェック自体が失敗しても `return` でスキップ

---

### 3. NULL チェック（例外を投げない）

**場所：** `Services/Upsert/UpsertService.cs` 行 1374-1378, 1421-1425

```csharp
// 新規作成時
if (!existingProduct.GCategoryId.HasValue)
{
    Logger.Error($"製品マスタ作成失敗: g_category_id が NULL です");
    Logger.Error("【原因】CATEGORY_1 属性が見つからないか、カテゴリIDへの変換に失敗しました");
    return;  // スキップ（例外は投げない）
}

// 更新時
if (!existingProduct.GCategoryId.HasValue)
{
    Logger.Error($"製品マスタ更新失敗: g_category_id が NULL です");
    Logger.Error("【原因】CATEGORY_1 属性が見つからないか、カテゴリIDへの変換に失敗しました");
    return;  // スキップ（例外は投げない）
}
```

**重要ポイント：**
- 以前は `throw new InvalidOperationException()` で例外を投げていた
- 現在は `return` でスキップするだけ
- これによりトランザクション全体がロールバックされなくなった

---

### 4. Repository層のエラーハンドリング

**場所：** `Repositories/Product/ProductManagementRepository.cs` 行 24-48

```csharp
public async Task<long?> FindActiveProductManagementIdAsync(...)
{
    try
    {
        // 既存の製品IDを検索
        return await connection.ExecuteScalarAsync<long?>(...);
    }
    catch (PostgresException ex) when (ex.SqlState == PostgresErrorCodes.UndefinedTable)
    {
        // テーブルが存在しない場合は null を返す（エラーとして扱わない）
        return null;
    }
}
```

**重要ポイント：**
- テーブルが存在しない場合のエラーコード (`UndefinedTable`) をキャッチ
- エラーを上位に投げずに `null` を返す
- これにより呼び出し元でエラーハンドリングが不要になる

---

## トランザクション境界

### 重要な設計決定

**1商品ごとに1トランザクション**

```
商品1の処理
  BEGIN TRANSACTION
    ├─ m_product_ident
    ├─ m_product
    ├─ m_product_eav
    └─ m_product_management （失敗しても影響なし）
  COMMIT

商品2の処理
  BEGIN TRANSACTION
    ├─ m_product_ident
    ├─ m_product
    ├─ m_product_eav
    └─ m_product_management （失敗しても影響なし）
  COMMIT
```

**メリット：**
- 商品1でエラーが発生しても、商品2は処理される
- ロック時間が短い
- 製品マスタのエラーが商品マスタに影響しない

---

## 確認方法

### 1. ログを確認

成功した場合：
```
[INFO] 商品マスタUPSERT: g_product_id=1, ...
[INFO] 商品EAV UPSERT完了: INSERT=10, UPDATE=5, SKIP=2
[INFO] 製品マスタ新規作成: g_product_management_id=1, ...
[INFO] 製品EAV UPSERT完了: INSERT=8, UPDATE=3, SKIP=1
```

製品マスタがスキップされた場合：
```
[INFO] 商品マスタUPSERT: g_product_id=1, ...
[INFO] 商品EAV UPSERT完了: INSERT=10, UPDATE=5, SKIP=2
[WARN] 製品マスタスキップ: m_product_management テーブルが存在しません
[WARN] 【対処方法】init/createTable1105.sql を実行してテーブルを作成してください
[INFO] ※ 商品マスタ（m_product, m_product_eav）のデータは正常に保存されます
```

製品マスタでエラーが発生した場合：
```
[INFO] 商品マスタUPSERT: g_product_id=1, ...
[INFO] 商品EAV UPSERT完了: INSERT=10, UPDATE=5, SKIP=2
[ERROR] 製品マスタ処理エラー（商品マスタは正常）: batch_id=XXX, temp_row_id=YYY, g_product_id=1, error=...
[ERROR] スタックトレース: ...
```

### 2. データベースを確認

```sql
-- 商品マスタが正常に挿入されているか確認
SELECT COUNT(*) FROM m_product WHERE batch_id = 'あなたのbatch_id';
-- 結果：件数が表示される ✅

-- 商品EAVが正常に挿入されているか確認
SELECT COUNT(*) FROM m_product_eav WHERE batch_id = 'あなたのbatch_id';
-- 結果：件数が表示される ✅

-- 製品マスタの状態を確認
SELECT COUNT(*) FROM m_product_management WHERE batch_id = 'あなたのbatch_id';
-- 結果：
--   - 正常な場合：件数が表示される ✅
--   - テーブルが存在しない場合：エラー ❌
--   - エラーで失敗した場合：0件 ⚠️（商品マスタは正常）
```

---

## まとめ

### ✅ 改善点

1. **完全な错误隔离**
   - 制品表の問題が商品表に影響しない
   - 商品表のデータは必ず保存される

2. **テーブル存在性チェック**
   - テーブルが存在しない場合は事前にスキップ
   - わかりやすいエラーメッセージを出力

3. **例外を投げない設計**
   - `throw` を `return` に変更
   - トランザクション全体のロールバックを防ぐ

4. **詳細なログ出力**
   - エラーの原因がすぐに分かる
   - 対処方法も表示される

### 📝 推奨される運用

1. **制品マスタテーブルを作成したい場合**
   ```bash
   # pgAdmin4で実行
   init/createTable1105.sql
   ```

2. **制品マスタなしで運用したい場合**
   - 何もしなくてOK
   - 商品マスタと商品EAVのデータは正常に保存される
   - ログに警告が出るが、無視して問題ない

3. **エラーが発生した場合**
   - ログを確認して原因を特定
   - 商品マスタのデータは保存されているか確認
   - 必要に応じて制品マスタテーブルを修正
