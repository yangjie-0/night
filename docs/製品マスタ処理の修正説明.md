# 製品マスタ処理の修正説明

## 問題の症状

製品マスタ（m_product_management）のコードを追加した後、以下の問題が発生：

```
❌ m_product にデータが挿入されない
❌ m_product_eav にデータが挿入されない
❌ m_product_management にもデータが挿入されない
```

**すべてのテーブルにデータが入らない状態**

---

## 原因の分析

### 根本原因：例外によるトランザクション全体のロールバック

```csharp
// 修正前のコード（問題あり）
BEGIN TRANSACTION
  ├─ 商品識別（m_product_ident）✅ 成功
  ├─ 商品マスタ（m_product）✅ 成功
  ├─ 商品EAV（m_product_eav）✅ 成功
  └─ 【KM会社】製品マスタ（m_product_management）
      └─ if (g_category_id == null) throw new InvalidOperationException(...);
          ↓
          例外が発生！❌
          ↓
ROLLBACK（トランザクション全体が取り消される）
          ↓
結果：すべてのテーブルにデータが入らない
```

### 具体的な問題箇所

**問題1：例外を投げていた**

```csharp
// 修正前（NG）
if (!existingProduct.GCategoryId.HasValue)
{
    throw new InvalidOperationException($"g_category_id が NULL のため製品マスタを作成できません");
    // ↑ この例外でトランザクション全体がロールバック！
}
```

**問題2：製品マスタの処理が外側の try-catch に含まれていた**

```csharp
// 修正前（NG）
try
{
    await UpsertProductAsync(...);        // 商品マスタ
    await UpsertProductEavAsync(...);     // 商品EAV
    await UpsertProductManagementAsync(...); // 製品マスタ（エラーが発生）
    await tx.CommitAsync();
}
catch (Exception ex)
{
    await tx.RollbackAsync(); // すべてロールバック！
}
```

---

## 修正内容

### 修正1：製品マスタ処理を独立したエラーハンドリングで囲む

**修正後のコード：**

```csharp
try
{
    await UpsertProductAsync(...);        // 商品マスタ ✅
    await UpsertProductEavAsync(...);     // 商品EAV ✅

    // 製品マスタは独立したエラーハンドリング
    if (string.Equals(batchRun.GroupCompanyCd, "KM", StringComparison.OrdinalIgnoreCase))
    {
        try
        {
            await UpsertProductManagementAsync(...); // 製品マスタ
        }
        catch (Exception pmEx)
        {
            // 製品マスタのエラーはログに記録するだけ
            Logger.Error($"製品マスタ処理エラー（商品マスタは正常）: {pmEx.Message}");
            // トランザクションはロールバックしない！
        }
    }

    await tx.CommitAsync(); // 商品マスタと商品EAVは正常にコミット ✅
}
catch (Exception ex)
{
    await tx.RollbackAsync(); // 商品マスタや商品EAVのエラーの場合のみ
}
```

### 修正2：例外を投げずに return する

**修正前（NG）：**

```csharp
if (!existingProduct.GCategoryId.HasValue)
{
    Logger.Error($"製品マスタ作成失敗: g_category_id が NULL です");
    throw new InvalidOperationException(...); // ❌ 例外を投げる
}
```

**修正後（OK）：**

```csharp
if (!existingProduct.GCategoryId.HasValue)
{
    Logger.Error($"製品マスタ作成失敗: g_category_id が NULL です");
    Logger.Error("【原因】CATEGORY_1 属性が見つからないか、カテゴリIDへの変換に失敗しました");
    return; // ✅ ログを記録して終了（例外は投げない）
}
```

---

## 修正後の動作

### 正常な場合

```
BEGIN TRANSACTION
  ├─ 商品識別（m_product_ident）✅ 成功
  ├─ 商品マスタ（m_product）✅ 成功
  ├─ 商品EAV（m_product_eav）✅ 成功
  └─ 【KM会社】製品マスタ（m_product_management）✅ 成功
COMMIT ✅

結果：すべてのテーブルにデータが正常に挿入される
```

### 製品マスタでエラーが発生した場合

```
BEGIN TRANSACTION
  ├─ 商品識別（m_product_ident）✅ 成功
  ├─ 商品マスタ（m_product）✅ 成功
  ├─ 商品EAV（m_product_eav）✅ 成功
  └─ 【KM会社】製品マスタ（m_product_management）
      ├─ g_category_id が NULL ❌
      └─ エラーログを記録して return
COMMIT ✅

結果：商品マスタと商品EAVは正常に挿入される
      製品マスタはスキップ（エラーログに記録される）
```

### 商品マスタでエラーが発生した場合

```
BEGIN TRANSACTION
  ├─ 商品識別（m_product_ident）✅ 成功
  ├─ 商品マスタ（m_product）❌ エラー
  └─ （後続の処理は実行されない）
ROLLBACK ❌

結果：すべてのテーブルにデータが挿入されない
      エラーは record_error テーブルに記録される
```

---

## 修正したファイル

### Services/Upsert/UpsertService.cs

#### 修正箇所1：製品マスタ処理の呼び出し（行334-367付近）

```csharp
// ステップ3-6: 【KM会社のみ】製品マスタのUPSERT
// 注意：製品マスタの処理でエラーが発生しても、商品マスタと商品EAVは正常にコミットする
if (string.Equals(batchRun.GroupCompanyCd, "KM", StringComparison.OrdinalIgnoreCase))
{
    try
    {
        // m_product の最新データを再取得
        var latestProduct = await _upsertRepository.GetProductAsync(connection, ident.GProductId, tx, cancellationToken);

        await UpsertProductManagementAsync(
            connection,
            tx,
            batchRun,
            recordGroupCompanyId,
            latestProduct,
            attrList,
            definitionMap,
            cancellationToken);
    }
    catch (Exception pmEx)
    {
        // エラーログを記録するだけで、トランザクションは継続
        Logger.Error($"製品マスタ処理エラー（商品マスタは正常）: batch_id={batchRun.BatchId}, temp_row_id={group.Key}, g_product_id={ident.GProductId}, error={pmEx.Message}");
        Logger.Error($"スタックトレース: {pmEx.StackTrace}");
    }
}
```

#### 修正箇所2：g_category_id の NULL チェック（行1346-1351付近）

```csharp
if (!existingProduct.GCategoryId.HasValue)
{
    Logger.Error($"製品マスタ作成失敗: g_category_id が NULL です (g_product_id={existingProduct.GProductId})");
    Logger.Error("【原因】CATEGORY_1 属性が見つからないか、カテゴリIDへの変換に失敗しました");
    return; // エラーログを記録して終了（例外は投げない）
}
```

#### 修正箇所3：g_category_id の NULL チェック（更新時）（行1393-1398付近）

```csharp
if (!existingProduct.GCategoryId.HasValue)
{
    Logger.Error($"製品マスタ更新失敗: g_category_id が NULL です (g_product_management_id={gProductManagementId})");
    Logger.Error("【原因】CATEGORY_1 属性が見つからないか、カテゴリIDへの変換に失敗しました");
    return; // エラーログを記録して終了（例外は投げない）
}
```

---

## 動作確認方法

### 1. ログの確認

**成功した場合：**
```
商品マスタUPSERT: ...
商品EAV UPSERT: ...
製品マスタUPSERT開始: source_product_management_cd=XXX, g_product_id=YYY
製品マスタ新規作成: g_product_management_id=ZZZ, source_product_management_cd=XXX
製品EAV UPSERT開始: ...
製品EAV UPSERT完了: INSERT=X, UPDATE=Y, SKIP=Z
```

**製品マスタでエラーが発生した場合：**
```
商品マスタUPSERT: ... ✅
商品EAV UPSERT: ... ✅
製品マスタUPSERT開始: source_product_management_cd=XXX, g_product_id=YYY
製品マスタ作成失敗: g_category_id が NULL です (g_product_id=YYY) ❌
【原因】CATEGORY_1 属性が見つからないか、カテゴリIDへの変換に失敗しました
※ ただし、商品マスタと商品EAVは正常にコミットされる ✅
```

### 2. データベースの確認

```sql
-- 商品マスタが正常に挿入されているか確認
SELECT COUNT(*) FROM m_product WHERE batch_id = '您的batch_id';
-- 結果：件数が表示される ✅

-- 商品EAVが正常に挿入されているか確認
SELECT COUNT(*) FROM m_product_eav WHERE batch_id = '您的batch_id';
-- 結果：件数が表示される ✅

-- 製品マスタの状態を確認
SELECT COUNT(*) FROM m_product_management WHERE batch_id = '您的batch_id';
-- 結果：
--   - 正常な場合：件数が表示される ✅
--   - エラーがあった場合：0件（商品マスタは正常） ✅
```

---

## まとめ

### 修正のポイント

1. ✅ **製品マスタの処理を独立したエラーハンドリングで囲んだ**
   - 製品マスタでエラーが発生しても、商品マスタと商品EAVは正常にコミット

2. ✅ **例外を投げずに return するように変更**
   - `throw new InvalidOperationException` → `return`
   - トランザクション全体がロールバックされなくなった

3. ✅ **詳細なエラーログを追加**
   - エラーの原因がすぐに分かるようになった

### 期待される動作

| ケース | 商品マスタ | 商品EAV | 製品マスタ | 説明 |
|-------|----------|---------|-----------|------|
| すべて正常 | ✅ 挿入 | ✅ 挿入 | ✅ 挿入 | すべてのテーブルにデータが入る |
| 製品マスタでエラー | ✅ 挿入 | ✅ 挿入 | ❌ スキップ | 商品データは正常に保存される |
| 商品マスタでエラー | ❌ ロールバック | ❌ ロールバック | ❌ 未実行 | すべてロールバック |

### 再発防止

今後、新しい処理を追加する場合は以下に注意：

1. ⚠️ **例外を投げる場合は慎重に**
   - トランザクション全体がロールバックされる
   - 可能な限り `return` で処理を終了する

2. ⚠️ **オプショナルな処理は独立したエラーハンドリングで囲む**
   - メインの処理に影響を与えないようにする

3. ⚠️ **詳細なログを記録する**
   - エラーの原因がすぐに分かるようにする
